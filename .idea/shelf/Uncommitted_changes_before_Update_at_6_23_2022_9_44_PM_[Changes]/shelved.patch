Index: grupo13-p2-tads/src/uy/edu/um/prog2/adt/tads/MyHash/MyHashImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package uy.edu.um.prog2.adt.tads.MyHash;\r\n\r\npublic class MyHashImpl<Key, Value> implements MyHash<Key, Value> {\r\n\r\n    private NodeHashTable<Key, Value>[] elements = new NodeHashTable[INITIAL_SIZE];\r\n    private final static int INITIAL_SIZE = 10;\r\n    public int load;\r\n    private final static float LOAD_FACTOR = 0.8f;\r\n\r\n    public void MyHashTableImpl()\r\n    {\r\n        this.elements = new NodeHashTable[INITIAL_SIZE];\r\n        load = 0;\r\n    }\r\n\r\n    public NodeHashTable<Key, Value>[] getElements() {\r\n        return elements;\r\n    }\r\n\r\n    public void setElements(NodeHashTable<Key, Value>[] elements) {\r\n        this.elements = elements;\r\n    }\r\n\r\n    public int getLoad() {\r\n        return load;\r\n    }\r\n\r\n    public void setLoad(int load) {\r\n        this.load = load;\r\n    }\r\n\r\n    @Override\r\n    public void put(Key K, Value V)\r\n    {\r\n        int position = K.hashCode() %  elements.length;\r\n        if (elements[position] == null || elements[position].isDeleted()\r\n                || elements[position].getKey().equals(K))\r\n        {\r\n            NodeHashTable<Key, Value> nodo = new NodeHashTable<>(K,V);\r\n            elements[position] = nodo;\r\n        }else\r\n        {\r\n            int nroColision = 1;\r\n            int newPosition = 0;\r\n\r\n            do {\r\n                nroColision++;\r\n                newPosition = (K.hashCode() + colision(nroColision)) % elements.length;\r\n            } while(elements[newPosition]!=null && !elements[newPosition].isDeleted()\r\n                    && nroColision < elements.length);\r\n\r\n            if(nroColision < elements.length)\r\n            {\r\n                NodeHashTable<Key, Value> node = new NodeHashTable<>(K,V);\r\n                elements[newPosition] = node; // Aca YO cambie position por new position\r\n            }\r\n        }\r\n        load++;\r\n        // me fijo lo del factor de carga\r\n        if (load >= elements.length*LOAD_FACTOR) //relacion entre largo y elementos cargados\r\n        {\r\n            rehash(elements.length*2);\r\n        }\r\n    }\r\n\r\n    private void rehash(int newSize)\r\n    {\r\n        NodeHashTable<Key, Value>[] newElements = new NodeHashTable[newSize];\r\n        NodeHashTable<Key, Value>[] oldElements = elements;\r\n        elements = newElements;\r\n        for (int i = 0; i<elements.length; i++)\r\n        {\r\n            if (elements[i] != null && !elements[i].isDeleted())\r\n            {\r\n                put(elements[i].getKey(), elements[i].getValue());\r\n            }\r\n        }\r\n    }\r\n\r\n    private int colision(int intento)\r\n    {\r\n        return intento;\r\n    }\r\n\r\n    @Override\r\n    public Value get(Key k) {\r\n\r\n        int posititon = k.hashCode() % elements.length;\r\n        Value exit = null;\r\n        if (this.elements[posititon] != null)\r\n        {\r\n            if (!this.elements[posititon].isDeleted()\r\n                    && this.elements[posititon].getKey().equals(k))\r\n            {\r\n                // encontre el valor\r\n                exit = elements[posititon].getValue();\r\n            }else{\r\n\r\n                //pudo haber una colision\r\n                int nroColision = 1;\r\n                int newPosition = 0;\r\n\r\n                do {\r\n                    nroColision++;\r\n                    newPosition = (k.hashCode() + colision(nroColision)) % elements.length;\r\n                } while(elements[newPosition]!=null && !elements[newPosition].isDeleted()\r\n                        && nroColision < elements.length);\r\n                if(nroColision < elements.length)\r\n                {\r\n                    if(elements[newPosition]!=null && !elements[newPosition].isDeleted())\r\n                    {\r\n                        exit = this.elements[newPosition].getValue();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return exit;\r\n    }\r\n\r\n    @Override\r\n    public void remove(Key K) {\r\n\r\n        int posititon = K.hashCode() % elements.length;\r\n        if (this.elements[posititon] != null) {\r\n            if (!this.elements[posititon].isDeleted()\r\n                    && this.elements[posititon].getKey().equals(K)) {\r\n                elements[posititon].setDeleted(true);\r\n                this.load--;\r\n            } else {\r\n                int nroColision = 1;\r\n                int newPosition = 0;\r\n                do {\r\n                    nroColision++;\r\n                    newPosition = (K.hashCode() + colision(nroColision)) % elements.length;\r\n                } while (elements[newPosition] != null && nroColision < elements.length && !elements[newPosition].getKey().equals(K));\r\n\r\n                if (elements[newPosition] != null && nroColision < elements.length) {\r\n                    elements[newPosition].setDeleted(true);\r\n                    this.load--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public int size() {\r\n        return elements.length;\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/grupo13-p2-tads/src/uy/edu/um/prog2/adt/tads/MyHash/MyHashImpl.java b/grupo13-p2-tads/src/uy/edu/um/prog2/adt/tads/MyHash/MyHashImpl.java
--- a/grupo13-p2-tads/src/uy/edu/um/prog2/adt/tads/MyHash/MyHashImpl.java	(revision 2e04356ec2b4f7d924f050afa746cca4642bfdb1)
+++ b/grupo13-p2-tads/src/uy/edu/um/prog2/adt/tads/MyHash/MyHashImpl.java	(date 1656030134741)
@@ -3,7 +3,7 @@
 public class MyHashImpl<Key, Value> implements MyHash<Key, Value> {
 
     private NodeHashTable<Key, Value>[] elements = new NodeHashTable[INITIAL_SIZE];
-    private final static int INITIAL_SIZE = 10;
+    private final static int INITIAL_SIZE = 20;
     public int load;
     private final static float LOAD_FACTOR = 0.8f;
 
